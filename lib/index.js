// Generated by CoffeeScript 2.5.1
(function() {
  var DEFAULT_HANDSHAKE_TIMEOUT_MS, PortalGun, RPCClient, SW_CONNECT_TIMEOUT_MS, _isEmpty, _map, selfWindow;

  _map = require('lodash/map');

  _isEmpty = require('lodash/isEmpty');

  RPCClient = require('./rpc_client');

  DEFAULT_HANDSHAKE_TIMEOUT_MS = 10000; // 10 seconds

  SW_CONNECT_TIMEOUT_MS = 5000; // 5s

  selfWindow = typeof window !== "undefined" && window !== null ? window : self;

  PortalGun = class PortalGun {
    /*
    @param {Object} config
    @param {Number} [config.timeout=3000] - request timeout (ms)
    @param {Function<Boolean>} config.isParentValidFn - restrict parent origin
    */
    constructor({timeout, handshakeTimeout, isParentValidFn, useSw} = {}) {
      var isInAppBrowser;
      this.setParent = this.setParent.bind(this);
      this.setInAppBrowserWindow = this.setInAppBrowserWindow.bind(this);
      this.replyInAppBrowserWindow = this.replyInAppBrowserWindow.bind(this);
      this.onMessageInAppBrowserWindow = this.onMessageInAppBrowserWindow.bind(this);
      // Binds global message listener
      // Must be called before .call()
      this.listen = this.listen.bind(this);
      this.close = this.close.bind(this);
      /*
      @param {String} method
      @param {...*} params
      @returns Promise
      */
      this.call = this.call.bind(this);
      this.onRequest = this.onRequest.bind(this);
      this.onMessage = this.onMessage.bind(this);
      /*
       * Register method to be called on child request, or local request fallback
      @param {String} method
      @param {Function} fn
       */
      this.on = this.on.bind(this);
      this.handshakeTimeout = handshakeTimeout;
      this.isParentValidFn = isParentValidFn;
      if (this.isParentValidFn == null) {
        this.isParentValidFn = function() {
          return true;
        };
      }
      if (timeout == null) {
        timeout = null;
      }
      if (this.handshakeTimeout == null) {
        this.handshakeTimeout = DEFAULT_HANDSHAKE_TIMEOUT_MS;
      }
      this.isListening = false;
      // window?._portalIsInAppBrowser is set by native app. on iOS it isn't set
      // soon enough, so we rely on userAgent
      isInAppBrowser = (typeof window !== "undefined" && window !== null ? window._portalIsInAppBrowser : void 0) || navigator.userAgent.indexOf('/InAppBrowser') !== -1;
      this.hasParent = ((typeof window !== "undefined" && window !== null) && window.self !== window.top) || isInAppBrowser;
      this.parent = typeof window !== "undefined" && window !== null ? window.parent : void 0;
      this.client = new RPCClient({
        timeout: timeout,
        postMessage: (msg, origin) => {
          var queue, ref;
          if (isInAppBrowser) {
            queue = (function() {
              try {
                return JSON.parse(localStorage['portal:queue']);
              } catch (error) {
                return null;
              }
            })();
            if (queue == null) {
              queue = [];
            }
            queue.push(msg);
            return localStorage['portal:queue'] = JSON.stringify(queue);
          } else {
            return (ref = this.parent) != null ? ref.postMessage(msg, origin) : void 0;
          }
        }
      });
      if (useSw == null) {
        useSw = navigator.serviceWorker && (typeof window !== "undefined" && window !== null) && window.location.protocol !== 'http:';
      }
      if (useSw) {
        // only use service workers if current page has one
        this.ready = new Promise((resolve, reject) => {
          var readyTimeout;
          readyTimeout = setTimeout(resolve, SW_CONNECT_TIMEOUT_MS);
          return navigator.serviceWorker.ready.catch(function() {
            console.log('caught sw error');
            return null;
          }).then((registration) => {
            var worker;
            worker = registration != null ? registration.active : void 0;
            if (worker) {
              this.sw = new RPCClient({
                timeout: timeout,
                postMessage: (msg, origin) => {
                  var swMessageChannel;
                  swMessageChannel = new MessageChannel();
                  if (swMessageChannel != null) {
                    swMessageChannel.port1.onmessage = (e) => {
                      return this.onMessage(e, {
                        isServiceWorker: true
                      });
                    };
                  }
                  return worker.postMessage(msg, [swMessageChannel.port2]);
                }
              });
            }
            clearTimeout(readyTimeout);
            return resolve();
          });
        });
      } else {
        this.ready = Promise.resolve(true);
      }
      // All parents must respond to 'ping' with @registeredMethods
      this.registeredMethods = {
        ping: () => {
          return Object.keys(this.registeredMethods);
        }
      };
      this.parentsRegisteredMethods = [];
    }

    setParent(parent) {
      this.parent = parent;
      return this.hasParent = true;
    }

    setInAppBrowserWindow(iabWindow, callback) {
      var readyEvent;
      this.iabWindow = iabWindow;
      // can't use postMessage, so this hacky executeScript works
      readyEvent = navigator.userAgent.indexOf('iPhone') !== -1 ? 'loadstop' : 'loadstart'; // for some reason need to wait for this on iOS
      this.iabWindow.addEventListener(readyEvent, () => {
        this.iabWindow.executeScript({
          code: 'window._portalIsInAppBrowser = true;'
        });
        clearInterval(this.iabInterval);
        return this.iabInterval = setInterval(() => {
          return this.iabWindow.executeScript({
            code: "localStorage.getItem('portal:queue');"
          }, (values) => {
            var err;
            try {
              values = JSON.parse(values != null ? values[0] : void 0);
              if (!_isEmpty(values)) {
                this.iabWindow.executeScript({
                  code: "localStorage.setItem('portal:queue', '[]')"
                });
              }
              return _map(values, callback);
            } catch (error) {
              err = error;
              return console.log(err, values);
            }
          });
        }, 100);
      });
      return this.iabWindow.addEventListener('exit', () => {
        return clearInterval(this.iabInterval);
      });
    }

    replyInAppBrowserWindow(data) {
      var escapedData;
      escapedData = data.replace(/'/g, "\'");
      return this.iabWindow.executeScript({
        code: `if(window._portalOnMessage) window._portalOnMessage('${escapedData}')`
      });
    }

    onMessageInAppBrowserWindow(data) {
      return this.onMessage({
        data: data,
        source: {
          postMessage: (data) => {
            // needs to be defined in native
            return this.call('browser.reply', {data});
          }
        }
      });
    }

    listen() {
      this.isListening = true;
      selfWindow.addEventListener('message', this.onMessage);
      // set via win.executeScript in cordova
      if (typeof window !== "undefined" && window !== null) {
        window._portalOnMessage = (eStr) => {
          return this.onMessage({
            debug: true,
            data: (function() {
              try {
                return JSON.parse(eStr);
              } catch (error) {
                console.log('error parsing', eStr);
                return null;
              }
            })()
          });
        };
      }
      this.clientValidation = this.client.call('ping', null, {
        timeout: this.handshakeTimeout
      }).then((registeredMethods) => {
        if (this.hasParent) {
          return this.parentsRegisteredMethods = this.parentsRegisteredMethods.concat(registeredMethods);
        }
      }).catch(function() {
        return null;
      });
      return this.swValidation = this.ready.then(() => {
        var ref;
        return (ref = this.sw) != null ? ref.call('ping', null, {
          timeout: this.handshakeTimeout
        }) : void 0;
      }).then((registeredMethods) => {
        return this.parentsRegisteredMethods = this.parentsRegisteredMethods.concat(registeredMethods);
      });
    }

    close() {
      this.isListening = true;
      return selfWindow.removeEventListener('message', this.onMessage);
    }

    call(method, ...params) {
      var localMethod;
      if (!this.isListening) {
        return new Promise(function(resolve, reject) {
          return reject(new Error('Must call listen() before call()'));
        });
      }
      localMethod = (method, params) => {
        var fn;
        fn = this.registeredMethods[method];
        if (!fn) {
          throw new Error('Method not found');
        }
        return fn.apply(null, params);
      };
      // TODO: clean this up
      return this.ready.then(() => {
        var parentError;
        if (this.hasParent) {
          parentError = null;
          return this.clientValidation.then(() => {
            if (this.parentsRegisteredMethods.indexOf(method) === -1) {
              return localMethod(method, params);
            } else {
              return this.client.call(method, params).then(function(result) {
                var localResult;
                // need to send back methods for all parent frames
                if (method === 'ping') {
                  localResult = localMethod(method, params);
                  return (result || []).concat(localResult);
                } else {
                  return result;
                }
              }).catch((err) => {
                parentError = err;
                if (this.sw) {
                  return this.sw.call(method, params).then(function(result) {
                    var localResult;
                    // need to send back methods for all parent frames
                    if (method === 'ping') {
                      localResult = localMethod(method, params);
                      return (result || []).concat(localResult);
                    } else {
                      return result;
                    }
                  }).catch(function() {
                    return localMethod(method, params);
                  });
                } else {
                  return localMethod(method, params);
                }
              }).catch(function(err) {
                if (err.message === 'Method not found' && parentError !== null) {
                  throw parentError;
                } else {
                  throw err;
                }
              });
            }
          });
        } else {
          return new Promise((resolve) => {
            if (this.sw) {
              return resolve(this.swValidation.then(() => {
                if (this.parentsRegisteredMethods.indexOf(method) === -1) {
                  return localMethod(method, params);
                } else {
                  return this.sw.call(method, params).then(function(result) {
                    var localResult;
                    // need to send back methods for all parent frames
                    if (method === 'ping') {
                      localResult = localMethod(method, params);
                      return (result || []).concat(localResult);
                    } else {
                      return result;
                    }
                  }).catch(function(err) {
                    return localMethod(method, params);
                  });
                }
              }));
            } else {
              return resolve(localMethod(method, params));
            }
          });
        }
      });
    }

    onRequest(reply, request) {
      var i, len, param, params, ref;
      // replace callback params with proxy functions
      params = [];
      ref = request.params || [];
      for (i = 0, len = ref.length; i < len; i++) {
        param = ref[i];
        if (RPCClient.isRPCCallback(param)) {
          (function(param) {
            return params.push(function(...args) {
              return reply(RPCClient.createRPCCallbackResponse({
                params: args,
                callbackId: param.callbackId
              }));
            });
          })(param);
        } else {
          params.push(param);
        }
      }
      // acknowledge request, prevent request timeout
      reply(RPCClient.createRPCRequestAcknowledgement({
        requestId: request.id
      }));
      return this.call(request.method, ...params).then(function(result) {
        return reply(RPCClient.createRPCResponse({
          requestId: request.id,
          result: result
        }));
      }).catch(function(err) {
        return reply(RPCClient.createRPCResponse({
          requestId: request.id,
          rPCError: RPCClient.createRPCError({
            code: RPCClient.ERROR_CODES.DEFAULT,
            data: err
          })
        }));
      });
    }

    onMessage(e, {isServiceWorker} = {}) {
      var err, message, reply, rpc;
      reply = function(message) {
        var ref;
        if (typeof window !== "undefined" && window !== null) {
          return (ref = e.source) != null ? ref.postMessage(JSON.stringify(message), '*') : void 0;
        } else {
          return e.ports[0].postMessage(JSON.stringify(message)); // silent
        }
      };
      try {
        message = typeof e.data === 'string' ? JSON.parse(e.data) : e.data;
        if (!RPCClient.isRPCEntity(message)) {
          throw new Error('Non-portal message');
        }
        if (RPCClient.isRPCRequest(message)) {
          return this.onRequest(reply, message);
        } else if (RPCClient.isRPCEntity(message)) {
          if (this.isParentValidFn(e.origin)) {
            rpc = isServiceWorker ? this.sw : this.client;
            return rpc.resolve(message);
          } else if (RPCClient.isRPCResponse(message)) {
            rpc = isServiceWorker ? this.sw : this.client;
            return rpc.resolve(RPCClient.createRPCResponse({
              requestId: message.id,
              rPCError: RPCClient.createRPCError({
                code: RPCClient.ERROR_CODES.INVALID_ORIGIN
              })
            }));
          } else {
            throw new Error('Invalid origin');
          }
        } else {
          throw new Error('Unknown RPCEntity type');
        }
      } catch (error) {
        err = error;
      }
    }

    on(method, fn) {
      return this.registeredMethods[method] = fn;
    }

  };

  module.exports = PortalGun;

}).call(this);
