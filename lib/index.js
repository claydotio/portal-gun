"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// Generated by CoffeeScript 2.5.1
(function () {
  var DEFAULT_HANDSHAKE_TIMEOUT_MS, PortalGun, RPCClient, SW_CONNECT_TIMEOUT_MS, _isEmpty, _map, selfWindow;

  _map = require('lodash/map');
  _isEmpty = require('lodash/isEmpty');
  RPCClient = require('./rpc_client');
  DEFAULT_HANDSHAKE_TIMEOUT_MS = 10000; // 10 seconds

  SW_CONNECT_TIMEOUT_MS = 5000; // 5s

  selfWindow = typeof window !== "undefined" && window !== null ? window : self;

  PortalGun = /*#__PURE__*/function () {
    /*
    @param {Object} config
    @param {Number} [config.timeout=3000] - request timeout (ms)
    @param {Function<Boolean>} config.isParentValidFn - restrict parent origin
    */
    function PortalGun() {
      var _this = this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          timeout = _ref.timeout,
          handshakeTimeout = _ref.handshakeTimeout,
          isParentValidFn = _ref.isParentValidFn,
          useSw = _ref.useSw;

      _classCallCheck(this, PortalGun);

      var isInAppBrowser;
      this.setParent = this.setParent.bind(this);
      this.setInAppBrowserWindow = this.setInAppBrowserWindow.bind(this);
      this.replyInAppBrowserWindow = this.replyInAppBrowserWindow.bind(this);
      this.onMessageInAppBrowserWindow = this.onMessageInAppBrowserWindow.bind(this); // Binds global message listener
      // Must be called before .call()

      this.listen = this.listen.bind(this);
      this.close = this.close.bind(this);
      /*
      @param {String} method
      @param {...*} params
      @returns Promise
      */

      this.call = this.call.bind(this);
      this.onRequest = this.onRequest.bind(this);
      this.onMessage = this.onMessage.bind(this);
      /*
       * Register method to be called on child request, or local request fallback
      @param {String} method
      @param {Function} fn
       */

      this.on = this.on.bind(this);
      this.handshakeTimeout = handshakeTimeout;
      this.isParentValidFn = isParentValidFn;

      if (this.isParentValidFn == null) {
        this.isParentValidFn = function () {
          return true;
        };
      }

      if (timeout == null) {
        timeout = null;
      }

      if (this.handshakeTimeout == null) {
        this.handshakeTimeout = DEFAULT_HANDSHAKE_TIMEOUT_MS;
      }

      this.isListening = false; // window?._portalIsInAppBrowser is set by native app. on iOS it isn't set
      // soon enough, so we rely on userAgent

      isInAppBrowser = (typeof window !== "undefined" && window !== null ? window._portalIsInAppBrowser : void 0) || navigator.userAgent.indexOf('/InAppBrowser') !== -1;
      this.hasParent = typeof window !== "undefined" && window !== null && window.self !== window.top || isInAppBrowser;
      this.parent = typeof window !== "undefined" && window !== null ? window.parent : void 0;
      this.client = new RPCClient({
        timeout: timeout,
        postMessage: function postMessage(msg, origin) {
          var queue, ref;

          if (isInAppBrowser) {
            queue = function () {
              try {
                return JSON.parse(localStorage['portal:queue']);
              } catch (error) {
                return null;
              }
            }();

            if (queue == null) {
              queue = [];
            }

            queue.push(msg);
            return localStorage['portal:queue'] = JSON.stringify(queue);
          } else {
            return (ref = _this.parent) != null ? ref.postMessage(msg, origin) : void 0;
          }
        }
      });

      if (useSw == null) {
        useSw = navigator.serviceWorker && typeof window !== "undefined" && window !== null && window.location.protocol !== 'http:';
      }

      if (useSw) {
        // only use service workers if current page has one
        this.ready = new Promise(function (resolve, reject) {
          var readyTimeout;
          readyTimeout = setTimeout(resolve, SW_CONNECT_TIMEOUT_MS);
          return navigator.serviceWorker.ready["catch"](function () {
            console.log('caught sw error');
            return null;
          }).then(function (registration) {
            var worker;
            worker = registration != null ? registration.active : void 0;

            if (worker) {
              _this.sw = new RPCClient({
                timeout: timeout,
                postMessage: function postMessage(msg, origin) {
                  var swMessageChannel;
                  swMessageChannel = new MessageChannel();

                  if (swMessageChannel != null) {
                    swMessageChannel.port1.onmessage = function (e) {
                      return _this.onMessage(e, {
                        isServiceWorker: true
                      });
                    };
                  }

                  return worker.postMessage(msg, [swMessageChannel.port2]);
                }
              });
            }

            clearTimeout(readyTimeout);
            return resolve();
          });
        });
      } else {
        this.ready = Promise.resolve(true);
      } // All parents must respond to 'ping' with @registeredMethods


      this.registeredMethods = {
        ping: function ping() {
          return Object.keys(_this.registeredMethods);
        }
      };
      this.parentsRegisteredMethods = [];
    }

    _createClass(PortalGun, [{
      key: "setParent",
      value: function setParent(parent) {
        this.parent = parent;
        return this.hasParent = true;
      }
    }, {
      key: "setInAppBrowserWindow",
      value: function setInAppBrowserWindow(iabWindow, callback) {
        var _this2 = this;

        var readyEvent;
        this.iabWindow = iabWindow; // can't use postMessage, so this hacky executeScript works

        readyEvent = navigator.userAgent.indexOf('iPhone') !== -1 ? 'loadstop' : 'loadstart'; // for some reason need to wait for this on iOS

        this.iabWindow.addEventListener(readyEvent, function () {
          _this2.iabWindow.executeScript({
            code: 'window._portalIsInAppBrowser = true;'
          });

          clearInterval(_this2.iabInterval);
          return _this2.iabInterval = setInterval(function () {
            return _this2.iabWindow.executeScript({
              code: "localStorage.getItem('portal:queue');"
            }, function (values) {
              var err;

              try {
                values = JSON.parse(values != null ? values[0] : void 0);

                if (!_isEmpty(values)) {
                  _this2.iabWindow.executeScript({
                    code: "localStorage.setItem('portal:queue', '[]')"
                  });
                }

                return _map(values, callback);
              } catch (error) {
                err = error;
                return console.log(err, values);
              }
            });
          }, 100);
        });
        return this.iabWindow.addEventListener('exit', function () {
          return clearInterval(_this2.iabInterval);
        });
      }
    }, {
      key: "replyInAppBrowserWindow",
      value: function replyInAppBrowserWindow(data) {
        var escapedData;
        escapedData = data.replace(/'/g, "\'");
        return this.iabWindow.executeScript({
          code: "if(window._portalOnMessage) window._portalOnMessage('".concat(escapedData, "')")
        });
      }
    }, {
      key: "onMessageInAppBrowserWindow",
      value: function onMessageInAppBrowserWindow(data) {
        var _this3 = this;

        return this.onMessage({
          data: data,
          source: {
            postMessage: function postMessage(data) {
              // needs to be defined in native
              return _this3.call('browser.reply', {
                data: data
              });
            }
          }
        });
      }
    }, {
      key: "listen",
      value: function listen() {
        var _this4 = this;

        this.isListening = true;
        selfWindow.addEventListener('message', this.onMessage); // set via win.executeScript in cordova

        if (typeof window !== "undefined" && window !== null) {
          window._portalOnMessage = function (eStr) {
            return _this4.onMessage({
              debug: true,
              data: function () {
                try {
                  return JSON.parse(eStr);
                } catch (error) {
                  console.log('error parsing', eStr);
                  return null;
                }
              }()
            });
          };
        }

        this.clientValidation = this.client.call('ping', null, {
          timeout: this.handshakeTimeout
        }).then(function (registeredMethods) {
          if (_this4.hasParent) {
            return _this4.parentsRegisteredMethods = _this4.parentsRegisteredMethods.concat(registeredMethods);
          }
        })["catch"](function () {
          return null;
        });
        return this.swValidation = this.ready.then(function () {
          var ref;
          return (ref = _this4.sw) != null ? ref.call('ping', null, {
            timeout: _this4.handshakeTimeout
          }) : void 0;
        }).then(function (registeredMethods) {
          return _this4.parentsRegisteredMethods = _this4.parentsRegisteredMethods.concat(registeredMethods);
        });
      }
    }, {
      key: "close",
      value: function close() {
        this.isListening = true;
        return selfWindow.removeEventListener('message', this.onMessage);
      }
    }, {
      key: "call",
      value: function call(method) {
        var _this5 = this;

        for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          params[_key - 1] = arguments[_key];
        }

        var localMethod;

        if (!this.isListening) {
          return new Promise(function (resolve, reject) {
            return reject(new Error('Must call listen() before call()'));
          });
        }

        localMethod = function localMethod(method, params) {
          var fn;
          fn = _this5.registeredMethods[method];

          if (!fn) {
            throw new Error('Method not found');
          }

          return fn.apply(null, params);
        }; // TODO: clean this up


        return this.ready.then(function () {
          var parentError;

          if (_this5.hasParent) {
            parentError = null;
            return _this5.clientValidation.then(function () {
              if (_this5.parentsRegisteredMethods.indexOf(method) === -1) {
                return localMethod(method, params);
              } else {
                return _this5.client.call(method, params).then(function (result) {
                  var localResult; // need to send back methods for all parent frames

                  if (method === 'ping') {
                    localResult = localMethod(method, params);
                    return (result || []).concat(localResult);
                  } else {
                    return result;
                  }
                })["catch"](function (err) {
                  parentError = err;

                  if (_this5.sw) {
                    return _this5.sw.call(method, params).then(function (result) {
                      var localResult; // need to send back methods for all parent frames

                      if (method === 'ping') {
                        localResult = localMethod(method, params);
                        return (result || []).concat(localResult);
                      } else {
                        return result;
                      }
                    })["catch"](function () {
                      return localMethod(method, params);
                    });
                  } else {
                    return localMethod(method, params);
                  }
                })["catch"](function (err) {
                  if (err.message === 'Method not found' && parentError !== null) {
                    throw parentError;
                  } else {
                    throw err;
                  }
                });
              }
            });
          } else {
            return new Promise(function (resolve) {
              if (_this5.sw) {
                return resolve(_this5.swValidation.then(function () {
                  if (_this5.parentsRegisteredMethods.indexOf(method) === -1) {
                    return localMethod(method, params);
                  } else {
                    return _this5.sw.call(method, params).then(function (result) {
                      var localResult; // need to send back methods for all parent frames

                      if (method === 'ping') {
                        localResult = localMethod(method, params);
                        return (result || []).concat(localResult);
                      } else {
                        return result;
                      }
                    })["catch"](function (err) {
                      return localMethod(method, params);
                    });
                  }
                }));
              } else {
                return resolve(localMethod(method, params));
              }
            });
          }
        });
      }
    }, {
      key: "onRequest",
      value: function onRequest(reply, request) {
        var i, len, param, params, ref; // replace callback params with proxy functions

        params = [];
        ref = request.params || [];

        for (i = 0, len = ref.length; i < len; i++) {
          param = ref[i];

          if (RPCClient.isRPCCallback(param)) {
            (function (param) {
              return params.push(function () {
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  args[_key2] = arguments[_key2];
                }

                return reply(RPCClient.createRPCCallbackResponse({
                  params: args,
                  callbackId: param.callbackId
                }));
              });
            })(param);
          } else {
            params.push(param);
          }
        } // acknowledge request, prevent request timeout


        reply(RPCClient.createRPCRequestAcknowledgement({
          requestId: request.id
        }));
        return this.call.apply(this, [request.method].concat(_toConsumableArray(params))).then(function (result) {
          return reply(RPCClient.createRPCResponse({
            requestId: request.id,
            result: result
          }));
        })["catch"](function (err) {
          return reply(RPCClient.createRPCResponse({
            requestId: request.id,
            rPCError: RPCClient.createRPCError({
              code: RPCClient.ERROR_CODES.DEFAULT,
              data: err
            })
          }));
        });
      }
    }, {
      key: "onMessage",
      value: function onMessage(e) {
        var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            isServiceWorker = _ref2.isServiceWorker;

        var err, message, reply, rpc;

        reply = function reply(message) {
          var ref;

          if (typeof window !== "undefined" && window !== null) {
            return (ref = e.source) != null ? ref.postMessage(JSON.stringify(message), '*') : void 0;
          } else {
            return e.ports[0].postMessage(JSON.stringify(message)); // silent
          }
        };

        try {
          message = typeof e.data === 'string' ? JSON.parse(e.data) : e.data;

          if (!RPCClient.isRPCEntity(message)) {
            throw new Error('Non-portal message');
          }

          if (RPCClient.isRPCRequest(message)) {
            return this.onRequest(reply, message);
          } else if (RPCClient.isRPCEntity(message)) {
            if (this.isParentValidFn(e.origin)) {
              rpc = isServiceWorker ? this.sw : this.client;
              return rpc.resolve(message);
            } else if (RPCClient.isRPCResponse(message)) {
              rpc = isServiceWorker ? this.sw : this.client;
              return rpc.resolve(RPCClient.createRPCResponse({
                requestId: message.id,
                rPCError: RPCClient.createRPCError({
                  code: RPCClient.ERROR_CODES.INVALID_ORIGIN
                })
              }));
            } else {
              throw new Error('Invalid origin');
            }
          } else {
            throw new Error('Unknown RPCEntity type');
          }
        } catch (error) {
          err = error;
        }
      }
    }, {
      key: "on",
      value: function on(method, fn) {
        return this.registeredMethods[method] = fn;
      }
    }]);

    return PortalGun;
  }();

  module.exports = PortalGun;
}).call(void 0);